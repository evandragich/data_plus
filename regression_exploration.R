# Import Packages; no need to import data, as this file uses the master_df and name_legend objects generated by initial_preprocessing.R and subsequently
# global.R. If you get 'object not found' or similar errors, make sure you have run both of those, and have a master_df thats 9744 x 427 and a name_legend that's 421 x 9
library(tidyverse)

# Create numeric summarised df ----

# Create two vectors of column names, one with all "viable" survey questions, and one with our arbitrary "important" survey questions.
factor_columns <- name_legend %>%
  filter(data_source == "Exit Survey") %>%
  filter((happy_question)) %>%
  select(new_name) %>%
  pull()

factor_columns_streamlined <- name_legend %>%
  filter(data_source == "Exit Survey") %>%
  filter((display_streamlined)) %>%
  select(new_name) %>%
  pull()

# Make a clean dataframe with just program (for identification) and the columns in factor_columns 
happy_df_numeric <- master_df %>%
  #.[wave == "0",] %>%
  subset(select = c("program",factor_columns))


# Purrr was personally attacking me and i couldn't get these two calls into (1) ideally, a single map call, or (2) even a single pipe chain. Rip.
# But anyways, this reverses the factor levels (needed because they are already reversed to plot well in the app; this "undoes" that and makes them "normal"/intuitive again)
# and then coerces them to numeric, for all but the program column (handily filtered out via its 45 unique factors).
happy_df_numeric <- happy_df_numeric %>%
  map(., function(col) {
    if (nlevels(col) != 45) {
    fct_rev(col)
    } else {
      col
    }
  }) %>%
  as_tibble() 

happy_df_numeric <- happy_df_numeric %>%
  map(., function(col) {
    if (nlevels(col) != 45) {
      as.numeric(col)
    } else {
      col
    }
  }) %>%
  as_tibble()

# Here's the moneyshot: after grouping by program, summarise each column with the useful mean function (base mean()'s default behavior is to return NA if there are any NAs at all;
# this function simply omits those NAs and uses the quantity of valid entries as the denominator).
happy_df_numeric <- happy_df_numeric %>%
  group_by(program) %>%
  summarise_all(., ~ mean(.x, na.rm = TRUE))


# Write this to a csv to use for boxplots/reports, table regression for another day.
write_csv(happy_df_numeric, 'output/data/summarised_happy_questions_numeric.csv')



# Regression stuff: TL;DR: Sad and bad :( ----

# # Create new character vector of the column names I want to use as predictors, which is everything in happy_question *but* the outcome
# predictors <- factor_columns[!(factor_columns %in% c("os_overall_exper"))]
# 
# # Create my formula that predicts the outcome based on each of the above predictors; no higher order interactions here.
# fm <- as.formula(paste("os_overall_exper ~ ", paste(predictors, collapse= "+")))
# 
# # Save as model
# first_fit <- lm(fm, happy_df_numeric, na.action = na.exclude)
# 
# # Create matrix object from our numeric df (I played around with this a bit lol)
# x <- data.matrix(happy_df_numeric)
# 
# ### Try again with dropping any columns that have a NaN
# 
# dropped_df <- happy_df_numeric %>%
#   select_if(~ !any(is.nan(.)))
# 
# dropped_predictors <- predictors[predictors %in% names(dropped_df)]
# 
# # Create my formula that predicts the outcome based on each of the above predictors; no higher order interactions here.
# dropped_fm <- as.formula(paste("os_overall_exper ~ ", paste(dropped_predictors, collapse= "+")))
# 
# # Save as model
# dropped_fit <- lm(dropped_fm, dropped_df, na.action = na.exclude)
# 
# # We were able to fit all 45 values (yay!), but its just the first 45. Will need more input on which to try.






